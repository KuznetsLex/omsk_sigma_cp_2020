# STL (Стандартная библиотека шаблонов)

## Предисловие

Большинство структур данных из библиотеки STL имеют сходный синтаксис, например
- все они создаются почти одинаково(как-то так: `struct<elements_type> name(size)`)
- чтобы получить количество элементов в структуре, нужно вызвать метод size: `struct.size()`
- и т.д.

Так что не пугайтесь, тут не так уж много нового:)

P.S. Все использованные объекты подключаются библиотекой `<bits/stdc++.h>`  
`#include <bits/stdc++.h>`  - библиотека, включающая в себя все(ДА-ДА, ВООБЩЕ ВСЕ) остальные библиотеки  
Можно подключать только её и никаких `<iostream> и <vector>`

Работает под большинством компиляторов c++, но не под всеми, к сожалению.

## Содержание


[**Pair**](#pair)  
[Google - pair](https://en.cppreference.com/w/cpp/utility/pair) 

[**Tuple**](#tuple)  
[Google - tuple](https://en.cppreference.com/w/cpp/utility/tuple) 

[**Vector**](#vector)  
[Google - vector](https://en.cppreference.com/w/cpp/container/vector) 

[**Sort/reverse/etc**](#sort-reverse-и-другие-вещи-для-vector)  
[Google - swap](https://en.cppreference.com/w/cpp/algorithm/swap) 
[Google - sort](https://en.cppreference.com/w/cpp/algorithm/sort)  
[Google - reverse](https://en.cppreference.com/w/cpp/algorithm/reverse)  
[Google - lower_bound](https://en.cppreference.com/w/cpp/algorithm/lower_bound)  
[Google - upper_bound](https://en.cppreference.com/w/cpp/algorithm/upper_bound)  
 
[**Set**](#set)  
[Google - set](https://en.cppreference.com/w/cpp/container/set) 

[**Map**](#map)  
[Google - map](https://en.cppreference.com/w/cpp/container/map) 

[**Послесловие**](#послесловие)  

## Pair
(полезно на 100%)

Pair - пара значений любых типов. Любых. Типов.

<center><img src="pairmeme.jpg"></center>
<center>(Это скомпилится)</center>

Пара создаётся так: `pair<type1,type2> name`

Чтобы обратиться к первому элементу пары надо писать `p.first`, ко второму - `p.second`. Пару можно инициализировать вот так `pair<int,string> p = {2,"sigma"}`, или так `pair<int,string> p = make_pair(2,"sigma")`.

Часто хочется нагромоздить кучу пар, если у объекта более 2-х свойств(например точки в трехмерном пространстве), типа pair<int,pair<int,int>>. В таких случаях правильнее пользоваться собственноручно созданной структурой, или `tuple`-ом (про него подробнее написано ниже).

## Tuple 
(полезно на 75-100%)

Тапл создаётся на манер пары: `tuple<type1,type2,type3,...> name`  
Например: `tuple<int,int,string> t`  
Это как пара, только элементов может быть сколько угодно(по вашему выбору).

Чтобы присвоить значение таплу, нужно воспользоваться методом `make_tuple(val1,val2,val3...)`  
Например `t = make_tuple(1,2,"привет")`

Чтобы получить доступ к i-му элементу нужно воспользоваться `get<i>(tuple)`, нумерация с нуля  
Например: `get<0>(t)` - первый элемент тапла

Чтобы "выгрузить" значения из tuple, существует функция `tie()`  
Например:  
```c++
tuple<int,int,string> t = make_tuple(1,2,"привет");
int a,b;
string s;
tie(a,b,s) = t;
```  
После выполнения этого куска кода, `a = 1, b = 2, s = "привет"`

*P.S. tuple нужны в основном для сортировки массива из tuple, потому что имеют встроенный компаратор. Подробнее об этом будет рассказано на паре див2 про сортировки.*

## Vector
(полезно на 100%)

Vector - динамический массив, т.е. такой массив, размер которого можно изменять, удалять элементы, вставлять элементы и т.д.

По факту **то же самое что и массив, только удобнее**. В ходе лекции мы часто будем говорить слово "массив", вместо "вектор", потому что они достаточно похожи.

<center><img src="vectormeme.jpg"></center>

Объявляется вектор так: `vector<тип_элементов> имя_вектора(размер_вектора, чем_заполнить)`

- Таким образом, пример вектора: `vector<int> v(10,0)` - массив из 10 элементов, заполненный нулями  
Аналогичный массив: `int v[10]`

- Чаще всего удобнее создавать вектор из нулей, поэтому есть ещё одна форма создания вектора:  
`vector<int> v(n)` - создаст вектор из n "пустых" элементов (*В этом случае вектор заполняется нулями*)

- Ой, а ещё можно инициализировать вектор своими значениями: `vector<int> v = {1,2,3,4,5,6}`

**Кстати, у вектора в качестве размера можно указать переменную(а не константу), в отличии от массива!**

Обращаться к элементу вектора нужно так же, как к массиву, т.е. v[i]  
Нумерация также начинается начинается с 0, т.е. первый элемент доступен как v[0]

### Основные методы

*На метод можно нажать чтобы почитать более подробно.*

[`vector.size()`](https://en.cppreference.com/w/cpp/container/vector/size) - возвращает размер(количество элементов) массива.

[`vector.front()`](https://en.cppreference.com/w/cpp/container/vector/front) - возвращает первый элемент массива, аналог vector[0]

[`vector.back()`](https://en.cppreference.com/w/cpp/container/vector/back) - возвращает последний элемент массива. *Достаточно удобно, чтобы не писать каждый раз v[v.size()-1]*

[`vector.push_back(element)`](https://en.cppreference.com/w/cpp/container/vector/push_back) - добавляет в конец массива element, увеличивает размер массива на 1.

[`vector.pop_back()`](https://en.cppreference.com/w/cpp/container/vector/pop_back) - удаляет последний элемент массива, уменьшает размер массива на 1, **не возвращает удаленное значение**.

*Асимптотика всех: O(1)* 

[`vector.resize(new_size) или vector.resize(new_size, element)`](https://en.cppreference.com/w/cpp/container/vector/resize) - меняет размер массива на new_size, также можно передать второй параметр element, тогда все новые элементы инициализируются этим значением.

*Асимптотика resize: O(n)*
 
Также есть методы [`vector.insert(element, pos)`](https://en.cppreference.com/w/cpp/container/vector/insert) и [`vector.erase(pointer)`](https://en.cppreference.com/w/cpp/container/vector/erase), с ними вы можете ознакомиться по ссылкам. Эти методы работают слишком долго и поэтому используются редко.

*Асимптотика insert и erase: O(n)*
 
### Методы, возвращающие указатели

Указатель на элемент - такая штука, которая знает, где элемент находится в памяти. Подробнее о том, зачем они нужны, мы поговорим позже.

[`vector.begin()`](https://en.cppreference.com/w/cpp/container/vector/begin) - указатель на первый элемент массива.

[`vector.end()`](https://en.cppreference.com/w/cpp/container/vector/end) - указатель на фикитвный элемент за последним.

[`vector.rbegin()`](https://en.cppreference.com/w/cpp/container/vector/rbegin) - указатель на последний элемент массива.

[`vector.rend()`](https://en.cppreference.com/w/cpp/container/vector/rend) - указатель на фиктивный элемент перед первым.

<center><img src="vectorendbegin.gif"></center>
<!--![Картинка чтобы понятнее было](vectorendbegin.gif)-->

*Асимптотика всех: O(1)* 

### Итерирование по vector

Можно пройти по всем элементам вектора по очереди:

```c++
for(auto t:vector){
	cout<<t<<" "; 
}
```

## Sort, reverse и другие вещи для vector
(полезно на 100%)

### Swap

Очень полезная функция. Можно передать ей две переменные одного ЛЮБОГО ТИПА(не только вектор) она поменяет местами их значения.
Например:

```c++
vector<int> a = {1,2,3}, b = {4,5};
swap(a,b);
//Теперь a = {4,5}, b = {1,2,3}
```

*Асимптотика: O(1) - очень быстро* 

### Sort

В олимпиадном программировании принято экономить время, поэтому вместо того, чтобы писать свою сортировку, можно использовать метод `sort()` библиотеки `<algorithm>`.

Чтобы отсортировать вектор **по возрастанию**, достаточно написать:  
`sort(v.begin(), v.end())` - в качестве параметров мы передали начало и конец вектора в памяти(указатели на начало и конец)  
(*В памяти вектор лежит в последовательных ячейках памяти*)

Чтобы отсортировать вектор **по убыванию**, достаточно поменять begin -> rbegin(reversed begin), end -> rend(reversed end), см. [картинку](#методы-возвращающие-указатели):  
`sort(v.rbegin(), v.rend())` - *в качестве параметров мы передали начало и конец "перевёрнутого" массива, теперь sort отсортирует опять по возрастанию, но сохранит результат в "перевёрнутом виде", т.е. по убыванию.*

Кстати sort работает и для обычных массивов: `sort(mas, mas+sz)`, где mas - массив, sz - его размер. 

*Асимптотика: O(nlog(n))* 

### Reverse

Чтобы перевернуть массив используем `reverse`:  
`reverse(v.begin(),v.end())`

*Асимптотика: O(n)* 

### Lower_bound and Upper_bound

Представим что мы имеем **возрастающий** вектор `vector<int> v = {1,2,3,5,7,9,10}`

Метод `lower_bound(v.begin(),v.end(),val)` вернёт указатель на **первый элемент больший или равный** val.  
Метод `upper_bound(v.begin(),v.end(),val)` вернёт указатель на **первый элемент строго больший** val.  
Оба они на вход принимают указатели на начало и конец возрастающего массива и **возвращают указатель на искомый элемент**  

Чтобы получить **индекс(число)** искомого элемента вычтем из полученного указателя указатель на начало массива, например:  
`int id = lower_bound(v.begin(), v.end(), 5) - v.begin()` = **3**, т.к. в массиве первое число >=5 равно 5 и находится на **третьей** позиции (считая с нуля)

*При вычитании указателей получается число, равное разнице между позициями указателей в памяти. Поскольку элементы вектора лежат в памяти последовательно, то, вычитая указатели, мы получаем разницу между индексами ячеек, на которые указывают указатели.*  
*т.е. id = 3 - 0 = **3**, что и требовалось доказать.*

*Асимптотика: O(log(n))* 

## Set
(полезно на 100%)

Set -  это контейнер, который автоматически сортирует добавляемые элементы в порядке возрастания. Но при добавлении одинаковых значений, set будет хранить только один его экземпляр. По другому его еще называют множеством.

Например, если добавлять в него последовательно эти элементы, то set будет выглядеть так:

Добавили: 1  ,  Set: 1      
Добавили: 3  ,  Set: 1 3   
Добавили: 2  ,  Set: 1 2 3   
Добавили: 2  ,  Set: 1 2 3    
Добавили: 6  ,  Set: 1 2 3 6   
Добавили: 5  ,  Set: 1 2 3 5 6  
Добавили: 6  ,  Set: 1 2 3 5 6  

Инициализируется set так: `set<тип_элементов> name`  
Например: `set<int> s`

Можно инициализировать сразу своими значениями, например:  
`set<int> s = {1,2,3,4,6}`  
*Но это редко нужно.*


### Методы

[`set.size()`](https://en.cppreference.com/w/cpp/container/set/size) - возвращает размер(количество элементов) множества

*Асимптотика: O(1)* 

[`set.insert(element)`](https://en.cppreference.com/w/cpp/container/set/insert) - вставляет element в множество

[`set.erase(element)`](https://en.cppreference.com/w/cpp/container/set/erase) - удаляет element из множества, если он там был

[`set.erase(pointer)`](https://en.cppreference.com/w/cpp/container/set/erase) - удаляет элемент по указателю на него.

[`set.find(val)`](https://en.cppreference.com/w/cpp/container/set/find) - возвращает указатель на элемент со значением val, *а если такого значения нет, то метод вернёт указатель на фиктивный элемент, т.е. set.end()*

*Асимптотика insert, erase, find: O(log(n))* 

Таким образом чтобы проверить, есть ли значение в множестве:

```c++
set<int> s;

if(s.find(val)!=s.end()){
	//Значение val есть
	cout<<val<<" есть"<<endl;
}
```

### Методы, возвращающие указатели

Всё аналогично [вектору](#методы-возвращающие-указатели).

[`set.begin()`](https://en.cppreference.com/w/cpp/container/set/begin) - указатель на первый элемент множества.

[`set.end()`](https://en.cppreference.com/w/cpp/container/set/end) - указатель на фикитвный элемент за последним.

[`set.rbegin()`](https://en.cppreference.com/w/cpp/container/set/rbegin) - указатель на последний элемент множества.

[`set.rend()`](https://en.cppreference.com/w/cpp/container/set/rend) - указатель на фиктивный элемент перед первым. 

*Асимптотика всех: O(1)* 

Чаще всего нужны begin и rbegin, потому что по ним можно получить первый(минимальный) и последний(максимальный) элементы множества. Делается это так:  
```c++
set<int> s = {1,2,3,4,5,6,7};
int mn = *s.begin();
cout<<"Min = "<<mn<<endl;
```  
То есть, чтобы получить значение, которое лежит по указателю, нужно поставить знак "звёздочка" перед указателем, другими словами разименовать.

**Кстати, нельзя удалять последний элемент так `set.erase(set.rbegin())`, но можно удалить последний элемент по значению `set.erase(*set.rbegin())`**  
*Так происходит, потому что указатель set.rbegin() имеет тип reverse_iterator, когда erase() принимает тип iterator*

### Итерирование по set

Можно пройти по всем элементам множества в порядке возрастания, аналогично [вектору](#итерирование-по-vector):

```c++
for(auto t:set){
	cout<<t<<" "; 
}
```

### Зачем нужен set

Чаще всего в олимпиадных задачах set нужен для того, чтобы: 
- Сначала закидывать в него элементы(insert)
- Брать первый-минимальный(begin) или последний-максимальный(rbegin) элемент, использовать в программе и 
	- удалять(erase)  
	- или обновлять, т.е. сначала удалить(erase), а потом добавить(insert) в изменённом виде  


## Map 
(полезно на 100%)

Map - это ассоциативный контейнер, который работает по принципу "ключ — значение". То есть он хранит набор пар, где первый элемент - ключ, второй - значение.  
Этот набор пар хранится в map отсортированным по ключу.

Инициализация: `map<key_type, val_type> name`, например:  
`map<string,int> m` 

- Добавить пару (ключ, значение) можно так: `m["name1"] = 1`, теперь в map лежит пара {"name1",1}

- Изменить значение по ключу можно так: `m["name1"] = 150`, теперь в map лежит пара {"name1",150} 

- По ключу можно получить значение так: `m["name1"]`, *однако если в мапе нет такого ключа, то мап вернёт "нулевой элемент", в случае int - 0*

*Асимптотика операции обращения по ключу: O(log(n))* 

### Методы

[`map.size()`](https://en.cppreference.com/w/cpp/container/map/size) - возвращает размер(количество пар) мапа

*Асимптотика: O(1)* 

[`map.erase(key)`](https://en.cppreference.com/w/cpp/container/map/erase) - удаляет пару из множества по ключу, если такой ключ был

[`map.find(key)`](https://en.cppreference.com/w/cpp/container/map/find) - возвращает указатель на пару, где ключ = key, *а если такого ключа нет, то метод вернёт указатель на фиктивный элемент, т.е. map.end()*

*Асимптотика erase и find: O(log(n))* 

Таким образом чтобы проверить, есть ли ключ в мапе

```c++
map<int,int> m;

if(m.find(key)!=m.end()){
	//Ключ key есть
	cout<<m[key]<<endl;
}
```

Из нужных всё. Также есть методы, возвращающие указатели, аналогично [вектору](#методы-возвращающие-указатели), но они редко нужны.

### Итерирование по map

Можно пройти по всем элементам map в порядке возрастания:

```c++
for(auto t:map){
	cout<<t.first<<" "<<t.second<<endl; //соответственно ключ и значение 
}
```

## Послесловие

P.S. Стоит понимать, что все эти структуры не ограничиваются `map<int,int>` или `pair<short, string>`  
Иногда вам придётся делать что-то такое: `map<int,vector<pair<int,int>>>` или такое: `set< pair<int,int> >`  
В этом смысле вы - творцы, так что экспериментируйте! 

Удачи на контесте.   
Если есть вопросы у див1, пишите в личку: https://vk.com/flekser_from_sirius  
див2: https://vk.com/luka5s5
___

## [Sigma Omsk](https://vk.com/sigma_omsk) 2020

