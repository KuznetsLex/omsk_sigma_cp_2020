# STL (Стандартная библиотека шаблонов)

## Предисловие

Большинство структур данных из библиотеки STL имеют сходный синтаксис, например
- все они создаются почти одинаково(как-то так: `struct<elements_type> name(size)`)
- чтобы получить количество элементов в структуре, нужно вызвать метод size: `struct.size()`
- и т.д.

Так что не пугайтесь, тут не так уж много нового:)

P.S. Все использованные объекты подключаются библиотекой `<bits/stdc++.h>`  
`#include <bits/stdc++.h>`  - библиотека, включающая в себя все(ДА-ДА, ВООБЩЕ ВСЕ) остальные библиотеки  
Можно подключать только её и никаких `<iostream> и <vector>`

Работает под большинством компиляторов c++, но не под всеми, к сожалению.

## Содержание


[**Pair**](#pair)  
[Google - pair](https://en.cppreference.com/w/cpp/utility/pair) 

[**Tuple**](#tuple)  
[Google - tuple](https://en.cppreference.com/w/cpp/utility/tuple) 

[**Vector**](#vector)  
[Google - vector](https://en.cppreference.com/w/cpp/container/vector) 

[**Sort/reverse/etc**](#sort-reverse-и-другие-вещи-для-vector)  
[Google - sort](https://en.cppreference.com/w/cpp/algorithm/sort)  
[Google - reverse](https://en.cppreference.com/w/cpp/algorithm/reverse)  
[Google - lower_bound](https://en.cppreference.com/w/cpp/algorithm/lower_bound)  
[Google - upper_bound](https://en.cppreference.com/w/cpp/algorithm/upper_bound)  
[Google - swap](https://en.cppreference.com/w/cpp/algorithm/swap)  
 
[**Set**](#set)  
[Google - set](https://en.cppreference.com/w/cpp/container/set) 

[**Map**](#map)  
[Google - map](https://en.cppreference.com/w/cpp/container/map) 

[**Queue**](#queue)  
[Google - queue](https://en.cppreference.com/w/cpp/container/queue) 

[**Stack**](#stack)  
[Google - stack](https://en.cppreference.com/w/cpp/container/stack) 

[**Deque**](#deque)  
[Google - deque](https://en.cppreference.com/w/cpp/container/deque) 

[**Div1**](#div1)  

[**Послесловие**](#послесловие)  

## Pair
(полезно на 100%)

Pair - пара значений любых типов. Любых. Типов.

<center><img src="pairmeme.jpg"></center>
<center>(Это скомпилится)</center>

Пара создаётся так: `pair<type1,type2> name`

Чтобы обратиться к первому элементу пары надо писать `p.first`, ко второму - `p.second`. Пару можно инициализировать вот так `pair<int,string> p = {2,"sigma"}`, или так `pair<int,string> p = make_pair(2,"sigma")`.

Часто хочется нагромоздить кучу пар, если у объекта более 2-х свойств(например точки в трехмерном пространстве), типа pair<int,pair<int,int>>. В таких случаях правильнее пользоваться собственноручно созданной структурой, или `tuple`-ом (про него подробнее написано ниже).

## Tuple 
(полезно на 75-100%)

Тапл создаётся на манер пары: `tuple<type1,type2,type3,...> name`  
Например: `tuple<int,int,string> t`  
Это как пара, только элементов может быть сколько угодно(по вашему выбору).

Чтобы присвоить значение таплу, нужно воспользоваться методом `make_tuple(val1,val2,val3...)`  
Например `t = make_tuple(1,2,"привет")`

Чтобы получить доступ к i-му элементу нужно воспользоваться `get<i>(tuple)`, нумерация с нуля  
Например: `get<0>(t)` - первый элемент тапла

Чтобы "выгрузить" значения из tuple, существует функция `tie()`  
Например:  
```c++
tuple<int,int,string> t = make_tuple(1,2,"привет");
int a,b;
string s;
tie(a,b,s) = t;
```  
После выполнения этого куска кода, `a = 1, b = 2, s = "привет"`

*P.S. tuple нужны в основном для сортировки массива из tuple, потому что имеют встроенный компаратор. Подробнее об этом будет рассказано на паре див2 про сортировки.*

## Vector
(полезно на 100%)

Vector - динамический массив, т.е. такой массив, размер которого можно изменять, удалять элементы, вставлять элементы и т.д.

По факту **то же самое что и массив, только удобнее**. В ходе лекции мы часто будем говорить слово "массив", вместо "вектор", потому что они достаточно похожи.

<center><img src="vectormeme.jpg"></center>

Объявляется вектор так: `vector<тип_элементов> имя_вектора(размер_вектора, чем_заполнить)`

- Таким образом, пример вектора: `vector<int> v(10,0)` - массив из 10 элементов, заполненный нулями  
Аналогичный массив: `int v[10]`

- Чаще всего удобнее создавать вектор из нулей, поэтому есть ещё одна форма создания вектора:  
`vector<int> v(n)` - создаст вектор из n "пустых" элементов (*В этом случае вектор заполняется нулями*)

- Ой, а ещё можно инициализировать вектор своими значениями: `vector<int> v = {1,2,3,4,5,6}`

**Кстати, у вектора в качестве размера можно указать переменную(а не константу), в отличии от массива!**

Обращаться к элементу вектора нужно так же, как к массиву, т.е. v[i]  
Нумерация также начинается начинается с 0, т.е. первый элемент доступен как v[0]

### Основные методы

*На метод можно нажать чтобы почитать более подробно.*

[`vector.size()`](https://en.cppreference.com/w/cpp/container/vector/size) - возвращает размер(количество элементов) массива.

[`vector.front()`](https://en.cppreference.com/w/cpp/container/vector/front) - возвращает первый элемент массива, аналог vector[0]

[`vector.back()`](https://en.cppreference.com/w/cpp/container/vector/back) - возвращает последний элемент массива. *Достаточно удобно, чтобы не писать каждый раз v[v.size()-1]*

[`vector.push_back(element)`](https://en.cppreference.com/w/cpp/container/vector/push_back) - добавляет в конец массива element, увеличивает размер массива на 1.

[`vector.pop_back()`](https://en.cppreference.com/w/cpp/container/vector/pop_back) - удаляет последний элемент массива, уменьшает размер массива на 1, **не возвращает удаленное значение**.

*Асимптотика всех: O(1)* 

[`vector.resize(new_size) или vector.resize(new_size, element)`](https://en.cppreference.com/w/cpp/container/vector/resize) - меняет размер массива на new_size, также можно передать второй параметр element, тогда все новые элементы инициализируются этим значением.

*Асимптотика resize: O(n)*
 
Также есть методы [`vector.insert(element, pos)`](https://en.cppreference.com/w/cpp/container/vector/insert) и [`vector.erase(pointer)`](https://en.cppreference.com/w/cpp/container/vector/erase), с ними вы можете ознакомиться по ссылкам. Эти методы работают слишком долго и поэтому используются редко.

*Асимптотика insert и erase: O(n)*
 
### Методы, возвращающие указатели

Указатель на элемент - такая штука, которая знает, где элемент находится в памяти. Подробнее о том, зачем они нужны, мы поговорим позже.

[`vector.begin()`](https://en.cppreference.com/w/cpp/container/vector/begin) - указатель на первый элемент массива.

[`vector.end()`](https://en.cppreference.com/w/cpp/container/vector/end) - указатель на фикитвный элемент за последним.

[`vector.rbegin()`](https://en.cppreference.com/w/cpp/container/vector/rbegin) - указатель на последний элемент массива.

[`vector.rend()`](https://en.cppreference.com/w/cpp/container/vector/rend) - указатель на фиктивный элемент перед первым.

<center><img src="vectorendbegin.gif"></center>
<!--![Картинка чтобы понятнее было](vectorendbegin.gif)-->

*Асимптотика всех: O(1)* 

### Итерирование по vector

Можно пройти по всем элементам вектора по очереди:

```c++
for(auto t:vector){
	cout<<t<<" "; 
}
```

## Sort, reverse и другие вещи для vector
(полезно на 100%)

### Swap

Очень полезная функция. Можно передать ей две переменные одного ЛЮБОГО ТИПА(не только вектор) она поменяет местами их значения.
Например:

```c++
vector<int> a = {1,2,3}, b = {4,5};
swap(a,b);
//Теперь a = {4,5}, b = {1,2,3}
```

*Асимптотика: O(1) - очень быстро* 

### Sort

В олимпиадном программировании принято экономить время, поэтому вместо того, чтобы писать свою сортировку, можно использовать метод `sort()` библиотеки `<algorithm>`.

Чтобы отсортировать вектор **по возрастанию**, достаточно написать:  
`sort(v.begin(), v.end())` - в качестве параметров мы передали начало и конец вектора в памяти(указатели на начало и конец)  
(*В памяти вектор лежит в последовательных ячейках памяти*)

Чтобы отсортировать вектор **по убыванию**, достаточно поменять begin -> rbegin(reversed begin), end -> rend(reversed end), см. [картинку](#методы-возвращающие-указатели):  
`sort(v.rbegin(), v.rend())` - *в качестве параметров мы передали начало и конец "перевёрнутого" массива, теперь sort отсортирует опять по возрастанию, но сохранит результат в "перевёрнутом виде", т.е. по убыванию.*

Кстати sort работает и для обычных массивов: `sort(mas, mas+sz)`, где mas - массив, sz - его размер. 

*Асимптотика: O(nlog(n))* 

### Reverse

Чтобы перевернуть массив используем `reverse`:  
`reverse(v.begin(),v.end())`

*Асимптотика: O(n)* 

### Lower_bound and Upper_bound

Представим что мы имеем **возрастающий** вектор `vector<int> v = {1,2,3,5,7,9,10}`

Метод `lower_bound(v.begin(),v.end(),val)` вернёт указатель на **первый элемент больший или равный** val.  
Метод `upper_bound(v.begin(),v.end(),val)` вернёт указатель на **первый элемент строго больший** val.  
Оба они на вход принимают указатели на начало и конец возрастающего массива и **возвращают указатель на искомый элемент**  

Чтобы получить **индекс(число)** искомого элемента вычтем из полученного указателя указатель на начало массива, например:  
`int id = lower_bound(v.begin(), v.end(), 5) - v.begin()` = **3**, т.к. в массиве первое число >=5 равно 5 и находится на **третьей** позиции (считая с нуля)

*При вычитании указателей получается число, равное разнице между позициями указателей в памяти. Поскольку элементы вектора лежат в памяти последовательно, то, вычитая указатели, мы получаем разницу между индексами ячеек, на которые указывают указатели.*  
*т.е. id = 3 - 0 = **3**, что и требовалось доказать.*

*Асимптотика: O(log(n))* 

## Set
(полезно на 100%)

Set -  это контейнер, который автоматически сортирует добавляемые элементы в порядке возрастания. Но при добавлении одинаковых значений, set будет хранить только один его экземпляр. По другому его еще называют множеством.

Например, если добавлять в него последовательно эти элементы, то set будет выглядеть так:

Добавили: 1  ,  Set: 1      
Добавили: 3  ,  Set: 1 3   
Добавили: 2  ,  Set: 1 2 3   
Добавили: 2  ,  Set: 1 2 3    
Добавили: 6  ,  Set: 1 2 3 6   
Добавили: 5  ,  Set: 1 2 3 5 6  
Добавили: 6  ,  Set: 1 2 3 5 6  

Инициализируется set так: `set<тип_элементов> name`  
Например: `set<int> s`

Можно инициализировать сразу своими значениями, например:  
`set<int> s = {1,2,3,4,6}`  
*Но это редко нужно.*


### Методы

[`set.size()`](https://en.cppreference.com/w/cpp/container/set/size) - возвращает размер(количество элементов) множества

*Асимптотика: O(1)* 

[`set.insert(element)`](https://en.cppreference.com/w/cpp/container/set/insert) - вставляет element в множество

[`set.erase(element)`](https://en.cppreference.com/w/cpp/container/set/erase) - удаляет element из множества, если он там был

[`set.erase(pointer)`](https://en.cppreference.com/w/cpp/container/set/erase) - удаляет элемент по указателю на него.

[`set.find(val)`](https://en.cppreference.com/w/cpp/container/set/find) - возвращает указатель на элемент со значением val, *а если такого значения нет, то метод вернёт указатель на фиктивный элемент, т.е. set.end()*

*Асимптотика insert, erase, find: O(log(n))* 

Таким образом чтобы проверить, есть ли значение в множестве:

```c++
set<int> s;

if(s.find(val)!=s.end()){
	//Значение val есть
	cout<<val<<" есть"<<endl;
}
```

### Методы, возвращающие указатели

Всё аналогично [вектору](#методы-возвращающие-указатели).

[`set.begin()`](https://en.cppreference.com/w/cpp/container/set/begin) - указатель на первый элемент множества.

[`set.end()`](https://en.cppreference.com/w/cpp/container/set/end) - указатель на фикитвный элемент за последним.

[`set.rbegin()`](https://en.cppreference.com/w/cpp/container/set/rbegin) - указатель на последний элемент множества.

[`set.rend()`](https://en.cppreference.com/w/cpp/container/set/rend) - указатель на фиктивный элемент перед первым. 

*Асимптотика всех: O(1)* 

Чаще всего нужны begin и rbegin, потому что по ним можно получить первый(минимальный) и последний(максимальный) элементы множества. Делается это так:  
```c++
set<int> s = {1,2,3,4,5,6,7};
int mn = *s.begin();
cout<<"Min = "<<mn<<endl;
```  
То есть, чтобы получить значение, которое лежит по указателю, нужно поставить знак "звёздочка" перед указателем, другими словами разименовать.

**Кстати, нельзя удалять последний элемент так `set.erase(set.rbegin())`, но можно удалить последний элемент по значению `set.erase(*set.rbegin())`**  
*Так происходит, потому что указатель set.rbegin() имеет тип reverse_iterator, когда erase() принимает тип iterator*

### Итерирование по set

Можно пройти по всем элементам множества в порядке возрастания, аналогично [вектору](#итерирование-по-vector):

```c++
for(auto t:set){
	cout<<t<<" "; 
}
```

### Зачем нужен set

Чаще всего в олимпиадных задачах set нужен для того, чтобы: 
- Сначала закидывать в него элементы(insert)
- Брать первый-минимальный(begin) или последний-максимальный(rbegin) элемент, использовать в программе и 
	- удалять(erase)  
	- или обновлять, т.е. сначала удалить(erase), а потом добавить(insert) в изменённом виде  


## Map 
(полезно на 100%)

Map - это ассоциативный контейнер, который работает по принципу "ключ — значение". То есть он хранит набор пар, где первый элемент - ключ, второй - значение.  
Этот набор пар хранится в map отсортированным по ключу.

Инициализация: `map<key_type, val_type> name`, например:  
`map<string,int> m` 

- Добавить пару (ключ, значение) можно так: `m["name1"] = 1`, теперь в map лежит пара {"name1",1}

- Изменить значение по ключу можно так: `m["name1"] = 150`, теперь в map лежит пара {"name1",150} 

- По ключу можно получить значение так: `m["name1"]`, *однако если в мапе нет такого ключа, то мап вернёт "нулевой элемент", в случае int - 0*

*Асимптотика операции обращения по ключу: O(log(n))* 

### Методы

[`map.size()`](https://en.cppreference.com/w/cpp/container/map/size) - возвращает размер(количество пар) мапа

*Асимптотика: O(1)* 

[`map.erase(key)`](https://en.cppreference.com/w/cpp/container/map/erase) - удаляет пару из множества по ключу, если такой ключ был

[`map.find(key)`](https://en.cppreference.com/w/cpp/container/map/find) - возвращает указатель на пару, где ключ = key, *а если такого ключа нет, то метод вернёт указатель на фиктивный элемент, т.е. map.end()*

*Асимптотика erase и find: O(log(n))* 

Таким образом чтобы проверить, есть ли ключ в мапе

```c++
map<int,int> m;

if(m.find(key)!=m.end()){
	//Ключ key есть
	cout<<m[key]<<endl;
}
```

Из нужных всё. Также есть методы, возвращающие указатели, аналогично [вектору](#методы-возвращающие-указатели), но они редко нужны.

### Итерирование по map

Можно пройти по всем элементам map в порядке возрастания:

```c++
for(auto t:map){
	cout<<t.first<<" "<<t.second<<endl; //соответственно ключ и значение 
}
```

## Queue 
(полезно на 70%)

Очередь - структура данных, которая построена по принципу "последний вошёл - последним выйдешь". Весь функционал очереди ограничивается "добавить в конец очереди", "взять из начала очереди" 

Чтобы понять принцип работы очереди, вы можете представить себе магазинную очередь. И если вы стоите посреди нее, то чтобы вы оказались напротив кассы, сначала понадобится всех впереди стоящих людей обслужить. А вот для последнего человека в очереди нужно, чтобы кассир обслужил всех людей кроме него самого.

Т.е. элементы из начала очереди вытаскиваются в том порядке, в котором вы их ложили в конец.

Инициализация: `queue<type> name`, например: `queue<int> q`

### Методы

[`queue.size()`](https://en.cppreference.com/w/cpp/container/queue/size) - возвращает размер(количество элементов) очереди

[`queue.front()`](https://en.cppreference.com/w/cpp/container/queue/front) - возвращает первый элемент очереди

[`queue.back()`](https://en.cppreference.com/w/cpp/container/queue/back) - возвращает последний элемент очереди

[`queue.push(element)`](https://en.cppreference.com/w/cpp/container/queue/push) - добавляет element в конец очереди

[`queue.pop()`](https://en.cppreference.com/w/cpp/container/queue/pop) - удаляет последний элемент из очереди

*Асимптотика всех: O(1)* 

Эта структура используется в алгоритме, который будет рассказан на этом курсе.

## Stack 
(полезно на 60%)

Стэк - структура данных, которая построена по принципу "последний вошёл - первым выйдёшь". Весь функционал сткэа ограничивается "добавить на верх стэка", "взять верхний элемент стэка"

Чтобы понять принцип работы стэка, вы можете представить себе стопку доминошек. Можно класть доминошки на верх стопки, а можно их оттуда брать. Снизу брать нельзя, потому что стопка обрушится:)

Инициализация: `stack<type> name`, например: `stack<int> st`

### Методы

[`stack.size()`](https://en.cppreference.com/w/cpp/container/stack/size) - возвращает размер(количество элементов) стэка

[`stack.top()`](https://en.cppreference.com/w/cpp/container/stack/top) - возвращает верхний элемент стэка

[`stack.push(element)`](https://en.cppreference.com/w/cpp/container/stack/push) - добавляет element на верх стэка

[`stack.pop()`](https://en.cppreference.com/w/cpp/container/stack/pop) - удаляет верхний элемент из стэка

*Асимптотика всех: O(1)* 

Эта структура используется в алгоритме, который, к сожалению, не будет рассказан на этом курсе.

## Deque 
(полезно на 50%)

Эта структура аналогична стэку, только в ней можно класть элементы и сверху, и снизу, а также брать и сверху, и снизу.

Инициализация: `deque<type> name`, например: `deque<int> dq`

### Методы

[`deque.size()`](https://en.cppreference.com/w/cpp/container/deque/size) - возвращает размер(количество элементов) дека

[`deque.front()`](https://en.cppreference.com/w/cpp/container/deque/front) - возвращает верхний элемент дека

[`deque.back()`](https://en.cppreference.com/w/cpp/container/deque/back) - возвращает нижний элемент дека

[`deque.push_front(element)`](https://en.cppreference.com/w/cpp/container/deque/push_front) - добавляет element на верх дека

[`deque.push_back(element)`](https://en.cppreference.com/w/cpp/container/deque/push_back) - добавляет element в низ дека

[`deque.pop_front()`](https://en.cppreference.com/w/cpp/container/deque/pop_front) - удаляет верхний элемент дека

[`deque.pop_back()`](https://en.cppreference.com/w/cpp/container/deque/pop_back) - удаляет нижний элемент дека

*Асимптотика всех: O(1)* 

Эта структура не используется в известных автору алгоритмах.

## Div1

### Vector vs stack

Заметим, что vector может работать как stack: в векторе можно добавлять элемент в конец, удалять из конца, получать доступ к последнему элементу.

Однако кто бы мог подумать, что stack работает медленнее на ~25%, чем вектор.

Вывод: вместо stack используем vector, и не надо запоминать ещё одну структуру.

### Unordered_set/unordered_map

Есть такие структуры unordered_set и unordered_map. Это аналоги set и map соответственно. Работают совершенно так же, т.е. можно в программе просто map "заменить на" unordered_map. 

Что изменится? Ответ: 
- возможно ваша программа станет работать чуть быстрее, а возможно чуть медленнее. *P.S. в этом году замена map -> unordered_map добавила автору 11 баллов по последней задаче на ИОИП*
- поскольку unordered = безпорядочный, то по unordered_map и unordered_set нельзя итерироваться и нельзя пользоваться указателями begin/end/rbegin/rend, поскольку порядка теперь нет
- *от последнего замечания unordered_set становится бесполезным, поскольку его суть - сохранять порядок, а вот unordered_map можно попробовать*  

P.S. говорят, что можно как-то самому в коде допиливать unordered структуры, чтобы они однозначно давали выгоду по времени. 

### Priority_queue

priority_queue - в целом аналог set/multiset, но может меньше:

[`priority_queue.top()`](https://en.cppreference.com/w/cpp/container/priority_queue/top) - возвращает наибольший элемент множества

[`priority_queue.push(element)`](https://en.cppreference.com/w/cpp/container/priority_queue/push) - добавляет element в множество

[`priority_queue.pop()`](https://en.cppreference.com/w/cpp/container/priority_queue/pop) - удаляет наибольший элемент из множества

Почему её стоит использовать? Ответ:
- Поскольку она может меньше, то её смогли реализовать более оптимально, т.е. работает быстрее. По ответам на stackoverflow: *"Set makes many memory allocations. Every element of set is stored at its own allocation. Priority_queue uses single allocation to store all elements."*

## Послесловие

P.S. Стоит понимать, что все эти структуры не ограничиваются `map<int,int>` или `pair<short, string>`  
Иногда вам придётся делать что-то такое: `map<int,vector<pair<int,int>>>` или такое: `set< pair<int,int> >`  
В этом смысле вы - творцы, так что экспериментируйте! 

Удачи на контесте.   
Если есть вопросы у див1, пишите в личку: https://vk.com/flekser_from_sirius  
див2: https://vk.com/luka5s5
___

## [Sigma Omsk](https://vk.com/sigma_omsk) 2020


